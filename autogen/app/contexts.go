// Code generated by goagen v1.4.0, DO NOT EDIT.
//
// API "feedpushr": Application Contexts
//
// Command:
// $ goagen
// --design=github.com/ncarlier/feedpushr/design
// --out=$(GOPATH)/src/github.com/ncarlier/feedpushr/autogen
// --version=v1.4.0

package app

import (
	"context"
	"github.com/goadesign/goa"
	"net/http"
	"strconv"
)

// CreateFeedContext provides the feed create action context.
type CreateFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Tags  *string
	Title *string
	URL   string
}

// NewCreateFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller create action.
func NewCreateFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramTags := req.Params["tags"]
	if len(paramTags) > 0 {
		rawTags := paramTags[0]
		rctx.Tags = &rawTags
	}
	paramTitle := req.Params["title"]
	if len(paramTitle) > 0 {
		rawTitle := paramTitle[0]
		rctx.Title = &rawTitle
	}
	paramURL := req.Params["url"]
	if len(paramURL) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("url"))
	} else {
		rawURL := paramURL[0]
		rctx.URL = rawURL
		if err2 := goa.ValidateFormat(goa.FormatURI, rctx.URL); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`url`, rctx.URL, goa.FormatURI, err2))
		}
	}
	return &rctx, err
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) Created(r *Feed) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// CreatedLink sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) CreatedLink(r *FeedLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// CreatedTiny sends a HTTP response with status code 201.
func (ctx *CreateFeedContext) CreatedTiny(r *FeedTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// DeleteFeedContext provides the feed delete action context.
type DeleteFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewDeleteFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller delete action.
func NewDeleteFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteFeedContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetFeedContext provides the feed get action context.
type GetFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewGetFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller get action.
func NewGetFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OK(r *Feed) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKLink sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OKLink(r *FeedLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *GetFeedContext) OKTiny(r *FeedTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListFeedContext provides the feed list action context.
type ListFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Limit int
	Page  int
}

// NewListFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller list action.
func NewListFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramLimit := req.Params["limit"]
	if len(paramLimit) == 0 {
		rctx.Limit = 10
	} else {
		rawLimit := paramLimit[0]
		if limit, err2 := strconv.Atoi(rawLimit); err2 == nil {
			rctx.Limit = limit
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("limit", rawLimit, "integer"))
		}
		if rctx.Limit < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`limit`, rctx.Limit, 1, true))
		}
	}
	paramPage := req.Params["page"]
	if len(paramPage) == 0 {
		rctx.Page = 1
	} else {
		rawPage := paramPage[0]
		if page, err2 := strconv.Atoi(rawPage); err2 == nil {
			rctx.Page = page
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("page", rawPage, "integer"))
		}
		if rctx.Page < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError(`page`, rctx.Page, 1, true))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListFeedContext) OK(r FeedCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.feed.v1+json; type=collection")
	}
	if r == nil {
		r = FeedCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *ListFeedContext) OKTiny(r FeedTinyCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.feed.v1+json; type=collection")
	}
	if r == nil {
		r = FeedTinyCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *ListFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *ListFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// StartFeedContext provides the feed start action context.
type StartFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStartFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller start action.
func NewStartFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*StartFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StartFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *StartFeedContext) Accepted() error {
	ctx.ResponseData.WriteHeader(202)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *StartFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StartFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// StopFeedContext provides the feed stop action context.
type StopFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID string
}

// NewStopFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller stop action.
func NewStopFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*StopFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := StopFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	return &rctx, err
}

// Accepted sends a HTTP response with status code 202.
func (ctx *StopFeedContext) Accepted() error {
	ctx.ResponseData.WriteHeader(202)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *StopFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *StopFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// UpdateFeedContext provides the feed update action context.
type UpdateFeedContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID    string
	Tags  *string
	Title *string
}

// NewUpdateFeedContext parses the incoming request URL and body, performs validations and creates the
// context used by the feed controller update action.
func NewUpdateFeedContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateFeedContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateFeedContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		rctx.ID = rawID
	}
	paramTags := req.Params["tags"]
	if len(paramTags) > 0 {
		rawTags := paramTags[0]
		rctx.Tags = &rawTags
	}
	paramTitle := req.Params["title"]
	if len(paramTitle) > 0 {
		rawTitle := paramTitle[0]
		rctx.Title = &rawTitle
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OK(r *Feed) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKLink sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OKLink(r *FeedLink) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// OKTiny sends a HTTP response with status code 200.
func (ctx *UpdateFeedContext) OKTiny(r *FeedTiny) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateFeedContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateFeedContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// CreateFilterContext provides the filter create action context.
type CreateFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateFilterPayload
}

// NewCreateFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller create action.
func NewCreateFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createFilterPayload is the filter create action payload.
type createFilterPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Name of the filter
	Name *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createFilterPayload) Validate() (err error) {
	if payload.Alias == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Publicize creates CreateFilterPayload from createFilterPayload
func (payload *createFilterPayload) Publicize() *CreateFilterPayload {
	var pub CreateFilterPayload
	if payload.Alias != nil {
		pub.Alias = *payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = *payload.Condition
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// CreateFilterPayload is the filter create action payload.
type CreateFilterPayload struct {
	// Alias of the filter
	Alias string `form:"alias" json:"alias" yaml:"alias" xml:"alias"`
	// Conditional expression of the output
	Condition string `form:"condition" json:"condition" yaml:"condition" xml:"condition"`
	// Name of the filter
	Name string `form:"name" json:"name" yaml:"name" xml:"name"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateFilterPayload) Validate() (err error) {
	if payload.Alias == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateFilterContext) Created(r *Filter) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateFilterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// DeleteFilterContext provides the filter delete action context.
type DeleteFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID int
}

// NewDeleteFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller delete action.
func NewDeleteFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteFilterContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteFilterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteFilterContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetFilterContext provides the filter get action context.
type GetFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID int
}

// NewGetFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller get action.
func NewGetFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetFilterContext) OK(r *Filter) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetFilterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetFilterContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListFilterContext provides the filter list action context.
type ListFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller list action.
func NewListFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListFilterContext) OK(r FilterCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.filter.v1+json; type=collection")
	}
	if r == nil {
		r = FilterCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// SpecsFilterContext provides the filter specs action context.
type SpecsFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSpecsFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller specs action.
func NewSpecsFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*SpecsFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SpecsFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SpecsFilterContext) OK(r FilterSpecCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.filter-spec.v1+json; type=collection")
	}
	if r == nil {
		r = FilterSpecCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// UpdateFilterContext provides the filter update action context.
type UpdateFilterContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      int
	Payload *UpdateFilterPayload
}

// NewUpdateFilterContext parses the incoming request URL and body, performs validations and creates the
// context used by the filter controller update action.
func NewUpdateFilterContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateFilterContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateFilterContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// updateFilterPayload is the filter update action payload.
type updateFilterPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Filter status
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Finalize sets the default values defined in the design.
func (payload *updateFilterPayload) Finalize() {
	var defaultEnabled = false
	if payload.Enabled == nil {
		payload.Enabled = &defaultEnabled
	}
}

// Publicize creates UpdateFilterPayload from updateFilterPayload
func (payload *updateFilterPayload) Publicize() *UpdateFilterPayload {
	var pub UpdateFilterPayload
	if payload.Alias != nil {
		pub.Alias = payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = payload.Condition
	}
	if payload.Enabled != nil {
		pub.Enabled = *payload.Enabled
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// UpdateFilterPayload is the filter update action payload.
type UpdateFilterPayload struct {
	// Alias of the filter
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Filter status
	Enabled bool `form:"enabled" json:"enabled" yaml:"enabled" xml:"enabled"`
	// Filter properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateFilterContext) OK(r *Filter) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateFilterContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateFilterContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetHealthContext provides the health get action context.
type GetHealthContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetHealthContext parses the incoming request URL and body, performs validations and creates the
// context used by the health controller get action.
func NewGetHealthContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetHealthContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetHealthContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetHealthContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// GetOpmlContext provides the opml get action context.
type GetOpmlContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetOpmlContext parses the incoming request URL and body, performs validations and creates the
// context used by the opml controller get action.
func NewGetOpmlContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetOpmlContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetOpmlContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetOpmlContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/xml")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetOpmlContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// UploadOpmlContext provides the opml upload action context.
type UploadOpmlContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewUploadOpmlContext parses the incoming request URL and body, performs validations and creates the
// context used by the opml controller upload action.
func NewUploadOpmlContext(ctx context.Context, r *http.Request, service *goa.Service) (*UploadOpmlContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UploadOpmlContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// Created sends a HTTP response with status code 201.
func (ctx *UploadOpmlContext) Created() error {
	ctx.ResponseData.WriteHeader(201)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UploadOpmlContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// CreateOutputContext provides the output create action context.
type CreateOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	Payload *CreateOutputPayload
}

// NewCreateOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller create action.
func NewCreateOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*CreateOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := CreateOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// createOutputPayload is the output create action payload.
type createOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Name of the output
	Name *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *createOutputPayload) Validate() (err error) {
	if payload.Alias == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Publicize creates CreateOutputPayload from createOutputPayload
func (payload *createOutputPayload) Publicize() *CreateOutputPayload {
	var pub CreateOutputPayload
	if payload.Alias != nil {
		pub.Alias = *payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = *payload.Condition
	}
	if payload.Name != nil {
		pub.Name = *payload.Name
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// CreateOutputPayload is the output create action payload.
type CreateOutputPayload struct {
	// Alias of the output
	Alias string `form:"alias" json:"alias" yaml:"alias" xml:"alias"`
	// Conditional expression of the output
	Condition string `form:"condition" json:"condition" yaml:"condition" xml:"condition"`
	// Name of the output
	Name string `form:"name" json:"name" yaml:"name" xml:"name"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Validate runs the validation rules defined in the design.
func (payload *CreateOutputPayload) Validate() (err error) {
	if payload.Alias == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "alias"))
	}
	if payload.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "name"))
	}
	if payload.Condition == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`raw`, "condition"))
	}
	return
}

// Created sends a HTTP response with status code 201.
func (ctx *CreateOutputContext) Created(r *Output) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 201, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *CreateOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// DeleteOutputContext provides the output delete action context.
type DeleteOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID int
}

// NewDeleteOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller delete action.
func NewDeleteOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*DeleteOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := DeleteOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// NoContent sends a HTTP response with status code 204.
func (ctx *DeleteOutputContext) NoContent() error {
	ctx.ResponseData.WriteHeader(204)
	return nil
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *DeleteOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *DeleteOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// GetOutputContext provides the output get action context.
type GetOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID int
}

// NewGetOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller get action.
func NewGetOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetOutputContext) OK(r *Output) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *GetOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *GetOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// ListOutputContext provides the output list action context.
type ListOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewListOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller list action.
func NewListOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*ListOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := ListOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *ListOutputContext) OK(r OutputCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.output.v1+json; type=collection")
	}
	if r == nil {
		r = OutputCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// SpecsOutputContext provides the output specs action context.
type SpecsOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewSpecsOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller specs action.
func NewSpecsOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*SpecsOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SpecsOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SpecsOutputContext) OK(r OutputSpecCollection) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.feedpushr.output-spec.v1+json; type=collection")
	}
	if r == nil {
		r = OutputSpecCollection{}
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// UpdateOutputContext provides the output update action context.
type UpdateOutputContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	ID      int
	Payload *UpdateOutputPayload
}

// NewUpdateOutputContext parses the incoming request URL and body, performs validations and creates the
// context used by the output controller update action.
func NewUpdateOutputContext(ctx context.Context, r *http.Request, service *goa.Service) (*UpdateOutputContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := UpdateOutputContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramID := req.Params["id"]
	if len(paramID) > 0 {
		rawID := paramID[0]
		if id, err2 := strconv.Atoi(rawID); err2 == nil {
			rctx.ID = id
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("id", rawID, "integer"))
		}
	}
	return &rctx, err
}

// updateOutputPayload is the output update action payload.
type updateOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Output status
	Enabled *bool `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// Finalize sets the default values defined in the design.
func (payload *updateOutputPayload) Finalize() {
	var defaultEnabled = false
	if payload.Enabled == nil {
		payload.Enabled = &defaultEnabled
	}
}

// Publicize creates UpdateOutputPayload from updateOutputPayload
func (payload *updateOutputPayload) Publicize() *UpdateOutputPayload {
	var pub UpdateOutputPayload
	if payload.Alias != nil {
		pub.Alias = payload.Alias
	}
	if payload.Condition != nil {
		pub.Condition = payload.Condition
	}
	if payload.Enabled != nil {
		pub.Enabled = *payload.Enabled
	}
	if payload.Props != nil {
		pub.Props = payload.Props
	}
	return &pub
}

// UpdateOutputPayload is the output update action payload.
type UpdateOutputPayload struct {
	// Alias of the output
	Alias *string `form:"alias,omitempty" json:"alias,omitempty" yaml:"alias,omitempty" xml:"alias,omitempty"`
	// Conditional expression of the output
	Condition *string `form:"condition,omitempty" json:"condition,omitempty" yaml:"condition,omitempty" xml:"condition,omitempty"`
	// Output status
	Enabled bool `form:"enabled" json:"enabled" yaml:"enabled" xml:"enabled"`
	// Output properties
	Props map[string]interface{} `form:"props,omitempty" json:"props,omitempty" yaml:"props,omitempty" xml:"props,omitempty"`
}

// OK sends a HTTP response with status code 200.
func (ctx *UpdateOutputContext) OK(r *Output) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 200, r)
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *UpdateOutputContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// NotFound sends a HTTP response with status code 404.
func (ctx *UpdateOutputContext) NotFound() error {
	ctx.ResponseData.WriteHeader(404)
	return nil
}

// PubPshbContext provides the pshb pub action context.
type PubPshbContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewPubPshbContext parses the incoming request URL and body, performs validations and creates the
// context used by the pshb controller pub action.
func NewPubPshbContext(ctx context.Context, r *http.Request, service *goa.Service) (*PubPshbContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := PubPshbContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *PubPshbContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *PubPshbContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// SubPshbContext provides the pshb sub action context.
type SubPshbContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
	HubChallenge    string
	HubLeaseSeconds *int
	HubMode         string
	HubTopic        string
}

// NewSubPshbContext parses the incoming request URL and body, performs validations and creates the
// context used by the pshb controller sub action.
func NewSubPshbContext(ctx context.Context, r *http.Request, service *goa.Service) (*SubPshbContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := SubPshbContext{Context: ctx, ResponseData: resp, RequestData: req}
	paramHubChallenge := req.Params["hub.challenge"]
	if len(paramHubChallenge) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.challenge"))
	} else {
		rawHubChallenge := paramHubChallenge[0]
		rctx.HubChallenge = rawHubChallenge
	}
	paramHubLeaseSeconds := req.Params["hub.lease_seconds"]
	if len(paramHubLeaseSeconds) > 0 {
		rawHubLeaseSeconds := paramHubLeaseSeconds[0]
		if hubLeaseSeconds, err2 := strconv.Atoi(rawHubLeaseSeconds); err2 == nil {
			tmp10 := hubLeaseSeconds
			tmp9 := &tmp10
			rctx.HubLeaseSeconds = tmp9
		} else {
			err = goa.MergeErrors(err, goa.InvalidParamTypeError("hub.lease_seconds", rawHubLeaseSeconds, "integer"))
		}
	}
	paramHubMode := req.Params["hub.mode"]
	if len(paramHubMode) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.mode"))
	} else {
		rawHubMode := paramHubMode[0]
		rctx.HubMode = rawHubMode
		if !(rctx.HubMode == "subscribe" || rctx.HubMode == "unsubscribe") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`hub.mode`, rctx.HubMode, []interface{}{"subscribe", "unsubscribe"}))
		}
	}
	paramHubTopic := req.Params["hub.topic"]
	if len(paramHubTopic) == 0 {
		err = goa.MergeErrors(err, goa.MissingParamError("hub.topic"))
	} else {
		rawHubTopic := paramHubTopic[0]
		rctx.HubTopic = rawHubTopic
		if err2 := goa.ValidateFormat(goa.FormatURI, rctx.HubTopic); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`hub.topic`, rctx.HubTopic, goa.FormatURI, err2))
		}
	}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *SubPshbContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "text/plain")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// BadRequest sends a HTTP response with status code 400.
func (ctx *SubPshbContext) BadRequest(r error) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/vnd.goa.error")
	}
	return ctx.ResponseData.Service.Send(ctx.Context, 400, r)
}

// GetSwaggerContext provides the swagger get action context.
type GetSwaggerContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetSwaggerContext parses the incoming request URL and body, performs validations and creates the
// context used by the swagger controller get action.
func NewGetSwaggerContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetSwaggerContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetSwaggerContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetSwaggerContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}

// GetVarsContext provides the vars get action context.
type GetVarsContext struct {
	context.Context
	*goa.ResponseData
	*goa.RequestData
}

// NewGetVarsContext parses the incoming request URL and body, performs validations and creates the
// context used by the vars controller get action.
func NewGetVarsContext(ctx context.Context, r *http.Request, service *goa.Service) (*GetVarsContext, error) {
	var err error
	resp := goa.ContextResponse(ctx)
	resp.Service = service
	req := goa.ContextRequest(ctx)
	req.Request = r
	rctx := GetVarsContext{Context: ctx, ResponseData: resp, RequestData: req}
	return &rctx, err
}

// OK sends a HTTP response with status code 200.
func (ctx *GetVarsContext) OK(resp []byte) error {
	if ctx.ResponseData.Header().Get("Content-Type") == "" {
		ctx.ResponseData.Header().Set("Content-Type", "application/json")
	}
	ctx.ResponseData.WriteHeader(200)
	_, err := ctx.ResponseData.Write(resp)
	return err
}
