// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "feedpushr": Application Media Types
//
// Command:
// $ goagen
// --design=github.com/ncarlier/feedpushr/design
// --out=$(GOPATH)/src/github.com/ncarlier/feedpushr/autogen
// --version=v1.3.1

package client

import (
	"github.com/goadesign/goa"
	"net/http"
	"time"
)

// A RSS feed (default view)
//
// Identifier: application/vnd.feedpushr.feed.v1+json; view=default
type Feed struct {
	// Date of creation
	Cdate time.Time `form:"cdate" json:"cdate" xml:"cdate"`
	// Number of consecutive aggregation errors
	ErrorCount *int `form:"errorCount,omitempty" json:"errorCount,omitempty" xml:"errorCount,omitempty"`
	// Last aggregation error
	ErrorMsg *string `form:"errorMsg,omitempty" json:"errorMsg,omitempty" xml:"errorMsg,omitempty"`
	// URL of the feed website
	HTMLURL *string `form:"htmlUrl,omitempty" json:"htmlUrl,omitempty" xml:"htmlUrl,omitempty"`
	// URL of the PubSubHubbud hub
	HubURL *string `form:"hubUrl,omitempty" json:"hubUrl,omitempty" xml:"hubUrl,omitempty"`
	// ID of feed (MD5 of the xmlUrl)
	ID string `form:"id" json:"id" xml:"id"`
	// Last aggregation pass
	LastCheck *time.Time `form:"lastCheck,omitempty" json:"lastCheck,omitempty" xml:"lastCheck,omitempty"`
	// Date of modification
	Mdate time.Time `form:"mdate" json:"mdate" xml:"mdate"`
	// Next aggregation pass
	NextCheck *time.Time `form:"nextCheck,omitempty" json:"nextCheck,omitempty" xml:"nextCheck,omitempty"`
	// Aggregation status
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Text attribute of the Feed
	Text *string `form:"text,omitempty" json:"text,omitempty" xml:"text,omitempty"`
	// Title of the Feed
	Title string `form:"title" json:"title" xml:"title"`
	// URL of the XML feed
	XMLURL string `form:"xmlUrl" json:"xmlUrl" xml:"xmlUrl"`
}

// Validate validates the Feed media type instance.
func (mt *Feed) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.XMLURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "xmlUrl"))
	}
	if mt.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}

	if mt.Status != nil {
		if !(*mt.Status == "running" || *mt.Status == "stopped") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.status`, *mt.Status, []interface{}{"running", "stopped"}))
		}
	}
	return
}

// A RSS feed (link view)
//
// Identifier: application/vnd.feedpushr.feed.v1+json; view=link
type FeedLink struct {
	// ID of feed (MD5 of the xmlUrl)
	ID string `form:"id" json:"id" xml:"id"`
	// URL of the XML feed
	XMLURL string `form:"xmlUrl" json:"xmlUrl" xml:"xmlUrl"`
}

// Validate validates the FeedLink media type instance.
func (mt *FeedLink) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.XMLURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "xmlUrl"))
	}
	return
}

// A RSS feed (tiny view)
//
// Identifier: application/vnd.feedpushr.feed.v1+json; view=tiny
type FeedTiny struct {
	// Date of creation
	Cdate time.Time `form:"cdate" json:"cdate" xml:"cdate"`
	// ID of feed (MD5 of the xmlUrl)
	ID string `form:"id" json:"id" xml:"id"`
	// Title of the Feed
	Title string `form:"title" json:"title" xml:"title"`
	// URL of the XML feed
	XMLURL string `form:"xmlUrl" json:"xmlUrl" xml:"xmlUrl"`
}

// Validate validates the FeedTiny media type instance.
func (mt *FeedTiny) Validate() (err error) {
	if mt.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if mt.XMLURL == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "xmlUrl"))
	}
	if mt.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "title"))
	}

	return
}

// DecodeFeed decodes the Feed instance encoded in resp body.
func (c *Client) DecodeFeed(resp *http.Response) (*Feed, error) {
	var decoded Feed
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeFeedLink decodes the FeedLink instance encoded in resp body.
func (c *Client) DecodeFeedLink(resp *http.Response) (*FeedLink, error) {
	var decoded FeedLink
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// DecodeFeedTiny decodes the FeedTiny instance encoded in resp body.
func (c *Client) DecodeFeedTiny(resp *http.Response) (*FeedTiny, error) {
	var decoded FeedTiny
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}

// FeedCollection is the media type for an array of Feed (default view)
//
// Identifier: application/vnd.feedpushr.feed.v1+json; type=collection; view=default
type FeedCollection []*Feed

// Validate validates the FeedCollection media type instance.
func (mt FeedCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// FeedCollection is the media type for an array of Feed (tiny view)
//
// Identifier: application/vnd.feedpushr.feed.v1+json; type=collection; view=tiny
type FeedTinyCollection []*FeedTiny

// Validate validates the FeedTinyCollection media type instance.
func (mt FeedTinyCollection) Validate() (err error) {
	for _, e := range mt {
		if e != nil {
			if err2 := e.Validate(); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// DecodeFeedCollection decodes the FeedCollection instance encoded in resp body.
func (c *Client) DecodeFeedCollection(resp *http.Response) (FeedCollection, error) {
	var decoded FeedCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeFeedTinyCollection decodes the FeedTinyCollection instance encoded in resp body.
func (c *Client) DecodeFeedTinyCollection(resp *http.Response) (FeedTinyCollection, error) {
	var decoded FeedTinyCollection
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return decoded, err
}

// DecodeErrorResponse decodes the ErrorResponse instance encoded in resp body.
func (c *Client) DecodeErrorResponse(resp *http.Response) (*goa.ErrorResponse, error) {
	var decoded goa.ErrorResponse
	err := c.Decoder.Decode(&decoded, resp.Body, resp.Header.Get("Content-Type"))
	return &decoded, err
}
